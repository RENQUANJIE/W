<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>伍的圣诞树</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #020202; font-family: 'Times New Roman', serif; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            z-index: 100;
            pointer-events: none;
        }

        .control-group {
            background: rgba(10, 10, 10, 0.8);
            border: 1px solid #d4af37;
            padding: 20px;
            border-radius: 8px;
            text-align: right;
            color: #d4af37;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(5px);
        }

        h1 {
            position: absolute;
            top: 30px;
            left: 40px;
            color: #fceda8;
            font-size: 4rem;
            font-weight: 100;
            letter-spacing: 2px;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.6);
            pointer-events: none;
            margin: 0;
            z-index: 10;
            font-family: 'Cinzel', serif;
        }

        /* Start Overlay for Audio Policy */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 999;
            color: #d4af37;
            cursor: pointer;
            transition: opacity 0.8s;
        }
        
        #loading-text {
            margin-top: 20px;
            font-size: 14px;
            color: #888;
        }
    </style>
    
    <!-- Three.js Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <!-- CLICK ANYWHERE TO START (Required for Audio) -->
    <div id="start-overlay">
        <h2 style="font-size: 2.5rem; letter-spacing: 5px;">CLICK TO ENTER</h2>
        <p style="font-size: 1rem; opacity: 0.8;">Double Click to Explode | Right Click to Assemble</p>
        <div id="loading-text">Loading Assets...</div>
    </div>

    <h1>Merry Christmas!</h1>

    <div id="ui-layer">
        <div class="control-group">
            <p style="font-size: 12px; color: #aaa; margin: 0 0 10px 0;">CONTROLS</p>
            <div style="font-size: 14px; line-height: 1.6;">
                <span style="color:white">Double Click</span>: EXPLODE<br>
                <span style="color:white">Left Click</span>: VIEW PHOTO<br>
                <span style="color:white">Right Click</span>: BACK / ASSEMBLE
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <audio id="bgm" loop></audio>

<script>
    // --- 资源配置区域 ---
    const ASSETS = {
        music: 'Mc.mp3',
        // 这里的名字必须和您文件夹里的图片名字完全一致
        images: [
            '1.jpg', 
            '2.jpg', 
            '3.jpg', 
            '4.jpg', 
            '5.jpg', 
            '6.jpg',
            '7.jpg',
            '8.jpg',
            '9.jpg',
            '10.jpg',
            '11.jpg',
            '12.jpg',

        ]
    };

    const CONFIG = {
        colorGreen: 0x1a472a,
        colorGold: 0xffd700,
        colorRed: 0xc41e3a,
        particleCount: 450, // 球体和方块的数量
        treeHeight: 50,
        treeRadius: 20,
        scatterRange: 80,
        bloomStrengthNormal: 1.4,
        bloomStrengthViewing: 0.3
    };

    const STATES = { TREE: 'TREE', SCATTERED: 'SCATTERED', VIEWING: 'VIEWING' };
    let currentState = STATES.TREE;
    
    let scene, camera, renderer, composer, bloomPass, controls;
    let particles = []; 
    let photos = []; 
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let clock = new THREE.Clock();
    let starMesh; 
    let currentViewedPhoto = null;
    let textureLoader = new THREE.TextureLoader();

    // --- 初始化 ---
    function init() {
        // 场景
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020202, 0.012);

        // 相机
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 20, 85);

        // 渲染器
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // 灯光系统
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const centerLight = new THREE.PointLight(0xffaa00, 2.0, 120);
        centerLight.position.set(10, 25, 10);
        scene.add(centerLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.5);
        fillLight.position.set(0, 10, 50);
        scene.add(fillLight);

        // 后期辉光 (Bloom)
        const renderScene = new THREE.RenderPass(scene, camera);
        bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = CONFIG.bloomStrengthNormal;
        bloomPass.radius = 0.5;

        composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 鼠标控制器
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.2;

        // 生成物体
        createStar(); 
        generateBaseParticles();
        loadLocalPhotos(); // 加载那6张图片

        // 事件监听
        window.addEventListener('resize', onWindowResize, false);
        renderer.domElement.addEventListener('pointerdown', onMouseDown, false);
        renderer.domElement.addEventListener('dblclick', onDoubleClick, false);
        window.addEventListener('contextmenu', onRightClick, false);
        
        animate();
    }

    // --- 加载本地照片逻辑 ---
    function loadLocalPhotos() {
        const loadingText = document.getElementById('loading-text');
        let loadedCount = 0;

        ASSETS.images.forEach((filename) => {
            textureLoader.load(
                filename, 
                // 成功回调
                (texture) => {
                    createPhotoMesh(texture);
                    loadedCount++;
                    loadingText.innerText = `Loaded ${loadedCount} / ${ASSETS.images.length} images...`;
                    if(loadedCount === ASSETS.images.length) {
                        loadingText.innerText = "Ready! Click to Start.";
                        loadingText.style.color = "#d4af37";
                    }
                },
                // 进度回调
                undefined,
                // 错误回调
                (err) => {
                    console.error("Error loading image:", filename, err);
                    loadingText.innerText = "Error: Check console (F12) - likely CORS issue. Use a local server.";
                    loadingText.style.color = "red";
                }
            );
        });
    }

    // --- 创建顶部五角星 ---
    function createStar() {
        const shape = new THREE.Shape();
        const outerRadius = 2.8;
        const innerRadius = 1.2;
        const points = 5;

        for (let i = 0; i < points * 2; i++) {
            const angle = (i * Math.PI) / points;
            const radius = (i % 2 === 0) ? outerRadius : innerRadius;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
        }
        shape.closePath();

        const extrudeSettings = { depth: 0.6, bevelEnabled: true, bevelThickness: 0.2, bevelSize: 0.2, bevelSegments: 3 };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        
        const material = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            metalness: 1.0,
            roughness: 0.1,
            emissive: 0xffaa00,
            emissiveIntensity: 0.8
        });

        starMesh = new THREE.Mesh(geometry, material);
        starMesh.position.set(0, CONFIG.treeHeight / 2 + 1.5, 0);
        starMesh.rotation.z = Math.PI; 
        
        scene.add(starMesh);
        
        starMesh.userData = {
            treePos: starMesh.position.clone(),
            scatterPos: calculateScatterPosition(),
            rotationSpeed: { x: 0.01, y: 0.01 }
        };
        particles.push(starMesh);
    }

    // --- 粒子系统 (球体 + 正方体) ---
    function generateBaseParticles() {
        const geoSphere = new THREE.SphereGeometry(0.6, 16, 16);
        const geoBox = new THREE.BoxGeometry(0.7, 0.7, 0.7);

        const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colorGreen, roughness: 0.4, emissive: 0x0a220a, emissiveIntensity: 0.3 });
        const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colorGold, metalness: 0.9, roughness: 0.1, emissive: 0x443300, emissiveIntensity: 0.5 });
        const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colorRed, roughness: 0.3, emissive: 0x440000, emissiveIntensity: 0.4 });

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const isGold = Math.random() > 0.8;
            const geo = Math.random() > 0.5 ? geoSphere : geoBox;
            const mat = isGold ? matGold : (Math.random() > 0.5 ? matRed : matGreen);
            
            const mesh = new THREE.Mesh(geo, mat);
            const treePos = calculateTreePosition(i, CONFIG.particleCount);
            const scatterPos = calculateScatterPosition();

            mesh.userData = {
                treePos: treePos,
                scatterPos: scatterPos,
                rotationSpeed: { x: (Math.random()-.5)*0.02, y: (Math.random()-.5)*0.02 },
                isPhoto: false
            };
            mesh.position.copy(treePos);
            mesh.lookAt(0, treePos.y, 0);
            scene.add(mesh);
            particles.push(mesh);
        }
    }

    // --- 照片 Mesh 创建 ---
    function createPhotoMesh(texture) {
        const aspect = texture.image.width / texture.image.height;
        const width = 5; // 照片尺寸
        const height = width / aspect;

        const geo = new THREE.PlaneGeometry(width, height);
        
        // 关键：toneMapped: false 保持照片原色清晰
        const mat = new THREE.MeshBasicMaterial({ 
            map: texture, 
            side: THREE.DoubleSide,
            toneMapped: false 
        });

        // 金边框
        const borderGeo = new THREE.PlaneGeometry(width + 0.3, height + 0.3);
        const borderMat = new THREE.MeshStandardMaterial({ color: CONFIG.colorGold, metalness: 1.0, roughness: 0.2 });
        const border = new THREE.Mesh(borderGeo, borderMat);
        border.position.z = -0.05;

        const mesh = new THREE.Mesh(geo, mat);
        mesh.add(border);

        // 将照片均匀分布在树的表面附近
        // 使用随机索引但偏向外层
        const index = Math.floor(Math.random() * CONFIG.particleCount);
        let treePos = calculateTreePosition(index, CONFIG.particleCount);
        
        // 让照片稍微浮在树的表面之外，不被球体遮挡
        treePos.x *= 1.4; 
        treePos.z *= 1.4;

        mesh.userData = {
            treePos: treePos,
            scatterPos: calculateScatterPosition(),
            rotationSpeed: { x: 0.005, y: 0.005 },
            isPhoto: true,
            originalScale: new THREE.Vector3(1, 1, 1)
        };
        mesh.position.copy(treePos);
        mesh.lookAt(0, treePos.y, 0);
        scene.add(mesh);
        particles.push(mesh);
        photos.push(mesh);
    }

    // --- 数学算法 ---
    function calculateTreePosition(index, total) {
        const h = CONFIG.treeHeight;
        const y = -h/2 + (index / total) * h;
        const r = (1 - (y + h/2)/h) * CONFIG.treeRadius;
        const angle = index * 2.4; // 黄金角分布
        return new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r);
    }

    function calculateScatterPosition() {
        const r = CONFIG.scatterRange * Math.cbrt(Math.random());
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        return new THREE.Vector3(
            r * Math.sin(phi) * Math.cos(theta), 
            r * Math.sin(phi) * Math.sin(theta), 
            r * Math.cos(phi)
        );
    }

    // --- 状态转换动画 ---
    function transitionTo(state, targetObj = null) {
        // 调整辉光强度，防止看照片时太亮
        const targetBloom = state === STATES.VIEWING ? CONFIG.bloomStrengthViewing : CONFIG.bloomStrengthNormal;
        new TWEEN.Tween(bloomPass)
            .to({ strength: targetBloom }, 1000)
            .start();

        const duration = 1500;

        particles.forEach(p => {
            if (state === STATES.VIEWING && p === targetObj) return;

            let target = new THREE.Vector3();
            let targetRot = new THREE.Euler();

            if (state === STATES.TREE) {
                target.copy(p.userData.treePos);
                // 树形态：面向中心轴
                const dummy = new THREE.Object3D(); dummy.position.copy(target); dummy.lookAt(0, target.y, 0);
                targetRot.copy(dummy.rotation);
            } else {
                target.copy(p.userData.scatterPos);
                targetRot.set(Math.random()*3, Math.random()*3, 0);
            }

            new TWEEN.Tween(p.position).to({x:target.x, y:target.y, z:target.z}, duration + Math.random()*500).easing(TWEEN.Easing.Exponential.InOut).start();
            new TWEEN.Tween(p.rotation).to({x:targetRot.x, y:targetRot.y, z:targetRot.z}, duration + Math.random()*500).start();
        });

        // 放大特定照片
        if (state === STATES.VIEWING && targetObj) {
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const viewPos = camera.position.clone().add(camDir.multiplyScalar(20)); 

            new TWEEN.Tween(targetObj.position).to({x:viewPos.x, y:viewPos.y, z:viewPos.z}, 1000).easing(TWEEN.Easing.Cubic.Out).start();
            
            // 计算朝向相机的旋转
            const m = new THREE.Matrix4().lookAt(viewPos, camera.position, camera.up);
            const q = new THREE.Quaternion().setFromRotationMatrix(m);
            const e = new THREE.Euler().setFromQuaternion(q);
            
            new TWEEN.Tween(targetObj.rotation).to({x:e.x, y:e.y, z:e.z}, 800).start();
            new TWEEN.Tween(targetObj.scale).to({x:3, y:3, z:3}, 1000).start(); // 放大3倍
            
            controls.autoRotate = false;
        }

        if (currentState === STATES.VIEWING && state !== STATES.VIEWING && currentViewedPhoto) {
            new TWEEN.Tween(currentViewedPhoto.scale).to({x:1, y:1, z:1}, 800).start();
        }

        if (state !== STATES.VIEWING) {
            controls.autoRotate = true;
            controls.autoRotateSpeed = state === STATES.TREE ? 1.2 : 0.2;
        }
        currentState = state;
    }

    // --- 交互处理 ---
    
    // 点击开始遮罩层（解决Autoplay限制）
    document.getElementById('start-overlay').addEventListener('click', function() {
        // 设置音乐路径
        const audio = document.getElementById('bgm');
        audio.src = ASSETS.music;
        
        audio.play().then(() => {
            console.log("Music playing");
        }).catch(e => {
            console.warn("Music failed to play. Check if Mc.mp3 exists.", e);
            alert("无法播放音乐：请确保文件夹内有 'Mc.mp3' 文件。");
        });

        // 隐藏遮罩
        this.style.opacity = '0';
        setTimeout(() => this.style.display = 'none', 800);
    });

    function onDoubleClick(event) {
        if (currentState === STATES.TREE) transitionTo(STATES.SCATTERED);
    }

    function onMouseDown(event) {
        if (event.button !== 0) return;
        if (currentState === STATES.SCATTERED) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            // 递归检测，因为照片有子物体（边框）
            const intersects = raycaster.intersectObjects(photos, true); 
            
            if (intersects.length > 0) {
                // 找到父级Mesh（如果是点到边框）
                let target = intersects[0].object;
                while(target.parent && !target.userData.isPhoto) {
                    target = target.parent;
                }
                
                if (target.userData.isPhoto) {
                    currentViewedPhoto = target;
                    transitionTo(STATES.VIEWING, target);
                }
            }
        }
    }

    function onRightClick(event) {
        event.preventDefault();
        if (currentState === STATES.VIEWING) {
            transitionTo(STATES.SCATTERED);
            currentViewedPhoto = null;
        } else if (currentState === STATES.SCATTERED) {
            transitionTo(STATES.TREE);
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        controls.update();
        const time = clock.getElapsedTime();

        if (currentState === STATES.TREE) {
            // 顶部星星旋转
            if(starMesh) starMesh.rotation.y += 0.015;
            
            // 呼吸灯效果
            particles.forEach((p, i) => {
                if(p.material.emissiveIntensity !== undefined && !p.userData.isPhoto) {
                    p.material.emissiveIntensity = 0.5 + Math.sin(time * 3 + i) * 0.3;
                }
            });
        } else {
            // 漂浮效果
            particles.forEach(p => {
                if(currentState === STATES.VIEWING && p === currentViewedPhoto) return;
                p.position.y += Math.sin(time + p.position.x) * 0.02;
                p.rotation.x += 0.002;
            });
        }

        composer.render();
    }

    init();

</script>
</body>
</html>